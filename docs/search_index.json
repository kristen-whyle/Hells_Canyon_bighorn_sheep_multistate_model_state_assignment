[["index.html", "Movement ecology of Hells Canyon bighorn sheep: multi-state model state assignment Chapter 1 Movement ecology of bighorn sheep in Hells Canyon 1.1 Hells Canyon bighorn sheep 1.2 Multi-state model", " Movement ecology of Hells Canyon bighorn sheep: multi-state model state assignment Kristen Whyle 2024-12-13 Chapter 1 Movement ecology of bighorn sheep in Hells Canyon This multi-state model state assignment workflow is part of a larger PhD project investigating the movement ecology of bighorn sheep (Ovis canadensis) in the Hells Canyon region of Idaho, Washington and Oregon. The work is being carried out by Kristen Whyle under the supervision of Dr. Simona Picardi at the University of Idaho, and in collaboration with the Idaho Department of Fish and Game, the Washington Department of Fish and Wildlife and the Oregon Department of Fish and Wildlife. Figure 1.1: Bighorn sheep in Hells Canyon Figure 1.2: Hells Canyon landscape 1.1 Hells Canyon bighorn sheep The Hells Canyon region of ID, OR, and WA is currently home to a metapopulation of bighorn sheep composed of several different populations (Figure 1.3). Figure 1.3: Hells Canyon Bighorn sheep populations Bighorn sheep are native to Hells Canyon but were extirpated by 1945, likely due to a combination of overharvesting and competition and disease introduced from livestock. Reintroductions began in 1971 and the metapopulation has been monitored ever since, including by collecting data on their movements by VHF/GPS collaring individuals (Figure 1.4). The first VHF data was collected in 1997 and the first GPS data was collected in 2005 and both continue to be collected today. Figure 1.4: GPS-collared bighorn sheep in Hells Canyon There have been multiple disease outbreaks in the metapopulation during this time, and disease continues to be a major threat. The main pathogen of concern is Mycoplasma ovipneumoniae, which causes pneumonia. It spreads to bighorn via contact with infected domestic sheep or goats or infected conspecifics, and can cause large population declines. These contacts depend on bighorn sheep movements, which makes understanding their movements important for conservation, and that is where this research project comes in. 1.2 Multi-state model One of the objectives of this project is to quantify the interactions between the population dynamics and spatial dynamics of these bighorn sheep, in particular to quantify how demographic and environmental factors shape herd ranges and the probability of out-of-range movements including forays and dispersals. To address this objective we are creating a multi-state model that will assign bighorn sheep locations to 1 of three different spatial states: 1) a home range state (for points located within an individuals home population) 2) an other-range state (for points located in any Hells Canyon population range other than an individual’s home population range) and 3) a transit state (for points that are not located within any bighorn sheep population range). It will also identify when individuals’ movement steps switch between states. Once states and state switches are identified by the model we can examine the probability of individuals switching between states based on environmental variables and population demography variables. In this workflow we focus only on the first two components of the multi-state model; assigning states and identifying state switches in the movement data. "],["data-inputs-and-entity-relationship-diagram.html", "Chapter 2 Data inputs and Entity Relationship Diagram 2.1 Database creation", " Chapter 2 Data inputs and Entity Relationship Diagram The input data for this multi-state model workflow include a track_xyt R object, which is a processed version of the bighorn sheep location data created from the “raw” data inputs in previous workflows (processing steps are not shown here; those workflows partially cleaned and formatted the data), as well as a shapefile containing the Hells Canyon bighorn sheep popultion range polygons delineated by managers at Fish &amp; Game/Wildlife. The “raw” data that was shared by the state wildlife agencies include separate data frames containing information on bighorn sheep locations, on individual animals, and on VHF/GPS collar deployments. Figure 2.1 shows how these data tables relate to each other in an Entity Relationship Diagram (ERD). Figure 2.1: ERD for Hells Canyon bighorn sheep data. PK indicates primary key and FK indicates foreign key. 2.1 Database creation While the rest of this workflow starts from the multi-state model inputs, here we show how the “raw” data tables relate to each other, and how they can be formatted and input into a SQL database. Below are the steps required to build a relational database containing the three tables described in the ERD above. 2.1.1 Load packages and initiate database # Load packages ---- library(DBI) library(RSQLite) # Create database ---- # for Hells Canyon bighorn sheep data bighorn_db &lt;- dbConnect(SQLite(), &quot;hells_canyon_bighorn_sheep.db&quot;) 2.1.2 Create animals table The animals table contains data on the individual bighorn sheep in the dataset and includes the following columns: animal_id (primary key; individual identity for each animal), population (the home population of an individual), sex, date_of_birth, and source (source indicates whether an individual is a resident of Hells Canyon who was never translocated (R), is a resident of Hells Canyon who was translocated within the Hells Canyon metapopulation (RT), or is a translocated animal originating from outside of the Hells Canyon metapopulation (T)). # Create animals table in SQL: ---- dbExecute(bighorn_db, &quot;CREATE TABLE animals ( animal_id char(6) NOT NULL PRIMARY KEY, population varchar(20), sex char(1) CHECK (sex IN (&#39;M&#39;, &#39;F&#39;, &#39;&#39;)), date_of_birth date, source varchar(2) CHECK (source IN (&#39;R&#39;, &#39;RT&#39;, &#39;T&#39;)) );&quot;) # Load animals csv into R animals &lt;- read.csv(&quot;input_data/animals.csv&quot;, stringsAsFactors = FALSE) # Check if column names match between SQL table and csv file colnames(animals) # re-name columns from animals data frame to match the SQL table created above colnames(animals) &lt;- c(&quot;animal_id&quot;, &quot;population&quot;, &quot;sex&quot;, &quot;source&quot;, &quot;date_of_birth&quot;) # Input data from csv into SQL table dbWriteTable(bighorn_db, &quot;animals&quot;, animals, append = TRUE) 2.1.3 Create collars table The collars table contains info about each collar deployment and includes the following columns: collar_deployment_id (primary key; unique identity for each collar deployment), animal_ID (foreign key linking the collars table with the animals table), collar_serial_number, deployment_start_date, deployment_end_date, collar_type, frequency, and manufacturer. # Create collars table in SQL: ---- dbExecute(bighorn_db, &quot;CREATE TABLE collars ( collar_deployment_id integer NOT NULL PRIMARY KEY AUTOINCREMENT, animal_id char(6), collar_serial_number varchar(14), deployment_start_date date, deployment_end_date date, collar_type varchar(14), frequency real, manufacturer varchar(25), FOREIGN KEY (animal_id) REFERENCES animals(animal_id) );&quot;) # Load collars csv into R collars &lt;- read.csv(&quot;input_data/collars.csv&quot;, stringsAsFactors = FALSE) # Check if column names match between SQL table and csv file colnames(collars) # re-name columns from collars data frame to match the SQL table created above colnames(collars) &lt;- c(&quot;animal_id&quot;, &quot;deployment_start_date&quot;, &quot;deployment_end_date&quot;, &quot;collar_type&quot;, &quot;frequency&quot;, &quot;manufacturer&quot;, &quot;collar_serial_number&quot;) # Input data from csv into SQL table dbWriteTable(bighorn_db, &quot;collars&quot;, collars, append = TRUE) 2.1.4 Create locations table The locations table contains info about each bighorn sheep location and includes the following columns: location_id (primary key; unique identity for each bighorn sheep location), collar_deployment_id (foreign key linking the locations table with the collars table), date, time, latitude, longitude, and location_type (either the location was recorded from a GPS-collar (GPS), or from a ground-based field survey (G) or an aerial-based field survey (A)). # Create locations table in SQL: ---- dbExecute(bighorn_db, &quot;CREATE TABLE locations ( location_id integer NOT NULL PRIMARY KEY AUTOINCREMENT, collar_deployment_id integer, date date, time char(8), latitude real, longitude real, location_type varchar(3), FOREIGN KEY (collar_deployment_id) REFERENCES collars(collar_deployment_id) );&quot;) # Load locations csv into R locations &lt;- read.csv(&quot;input_data/locations.csv&quot;, stringsAsFactors = FALSE) # create collar_deployment_id column and add it to this dataframe: ---- # based on the colar_deployment_id in the SQL table # pull the SQL collars table into the environment as an object sql_collars &lt;- dbGetQuery(bighorn_db, &quot;SELECT * FROM collars&quot;) # turn deployment_start_date into a date using lubridate package&#39;s dmy function sql_collars$deployment_start_date &lt;- lubridate::dmy(sql_collars$deployment_start_date) # turn deployment_end_date into a date using lubridate package&#39;s dmy function sql_collars$deployment_end_date &lt;- lubridate::dmy(sql_collars$deployment_end_date) # replace collar deployment_end_dates that are NA (haven&#39;t dropped yet) with today&#39;s date sql_collars[which(is.na(sql_collars$deployment_end_date)),]$deployment_end_date &lt;- Sys.Date() # add the appropriate collar_deployment_id to each row of the locations table locations$collar_deployment_id &lt;- do.call(&quot;rbind&quot;, lapply(1:nrow(locations), function(x){ print(x) # pull out the animal ID and date for each location animal_id &lt;- locations$ANIMALID[x] date &lt;- lubridate::mdy(locations$DATE[x]) # subset sql_collars to the animal ID and date range that matches the location # and return the appropriate collar_deployment_id collar_deployment_id &lt;- sql_collars[intersect(which(sql_collars$animal_id==animal_id), intersect(which(sql_collars$deployment_start_date &lt;= date), which(sql_collars$deployment_end_date &gt;= date))),]$collar_deployment_id[1] if (length(collar_deployment_id)==1){return(collar_deployment_id)} else {return(NA)} })) # Check if column names match between SQL table and csv file colnames(locations) # subset the locations dataframe to only the necessary columns: locations &lt;- locations[,c(33, 3:7)] # re-name columns from locations data frame to match the SQL table created above colnames(locations)[c(2:6)] &lt;- c(&quot;date&quot;,&quot;time&quot;,&quot;latitude&quot;, &quot;longitude&quot;, &quot;location_type&quot;) # Input data from csv into SQL table dbWriteTable(bighorn_db, &quot;locations&quot;, locations, append = TRUE) 2.1.5 Check database data # Check that data was properly loaded into SQL database ---- bighorn_db &lt;- dbConnect(RSQLite::SQLite(), &quot;hells_canyon_bighorn_sheep.db&quot;) # Check animals table dbGetQuery(bighorn_db, &quot;SELECT * FROM animals LIMIT 3;&quot;) ## animal_id population sex date_of_birth source ## 1 21LO19 Lostine F 5/15/2019 R ## 2 21LO27 Lostine F 5/15/2020 R ## 3 21LO03 Lostine F 5/15/2020 R # Check collars table dbGetQuery(bighorn_db, &quot;SELECT * FROM collars LIMIT 3;&quot;) ## collar_deployment_id animal_id collar_serial_number deployment_start_date ## 1 1 21LO19 23-Apr-21 ## 2 2 21LO27 23-Apr-21 ## 3 3 21LO03 3-Mar-21 ## deployment_end_date collar_type frequency manufacturer ## 1 None 0.000 ## 2 19-Jan-22 VHF 150.272 ATS ## 3 1-Mar-22 VHF 150.253 ATS # Check locations table dbGetQuery(bighorn_db, &quot;SELECT * FROM locations LIMIT 3;&quot;) ## location_id collar_deployment_id date time latitude longitude ## 1 1 1212 1/7/2020 0:00:00 45.85665 -116.7908 ## 2 2 1212 1/7/2020 4:00:00 45.85692 -116.7908 ## 3 3 1212 1/7/2020 8:00:00 45.85736 -116.7909 ## location_type ## 1 GPS ## 2 GPS ## 3 GPS "],["multi-state-model-1.html", "Chapter 3 Multi-state model 3.1 Setup: import, clean, and prepare data 3.2 State assignment 3.3 State-switches 3.4 Create additional summary data 3.5 Data visualization", " Chapter 3 Multi-state model This chapter goes through the multi-state model workflow of assigning bighorn sheep locations to one of the three different states described in Chapter 1, and identifying state-switches in the bighorn sheep movement trajectories. 3.1 Setup: import, clean, and prepare data 3.1.1 Import data First we will clear our R environment and load the necessary packages for this workflow. # clear environment rm(list=ls()) # load packages ---- library(terra) library(sf) library(tidyverse) Chapter 2 shows how the “raw” data tables relate to each other; here we will read in a location dataset that came from those “raw” tables and went through some cleaning steps (not shown) that included getting rid of poor quality/unreliable locations. This dataset is in the format of a track_xyt R object. nonsf_dat &lt;- do.call(&quot;rbind&quot;, readRDS(&quot;input_data/trk8a_partially_cleaned_alldata_2024-08.rds&quot;)) Now we will load the shapefile delineating population (aka herd) ranges. The population range boundaries in this shapefile have been defined by managers and may be updated in future iterations of this analysis. popn_ranges &lt;- read_sf(&quot;input_data/shapefiles/HellsCanyonHerds.shp&quot;) 3.1.2 Clean and format data Before we can assign locations to different states we need to make sure that the population names are consistent between the track_xyt location data object and the shapefile object so that we can appropriately assign each location to a state based on the population of the individual the location data point belongs to and the population (or non-population) the location point falls in within the shapefile. 3.1.2.1 Harmonize population names The ‘NAME’ column in the shapefile data refers to the population; for clarity we re-name that column ‘Population’ here: colnames(popn_ranges)[5] &lt;- &quot;Population&quot; Now we check the population names in each data source: # Population names in location data loc_popnames &lt;- unique(nonsf_dat$POPULATION) # Population names in shapefile shp_popnames &lt;- unique(popn_ranges$Population) Which population names match between the sources? # which population names match between the location data and shapefile: popname_matches &lt;- loc_popnames[which(loc_popnames %in% shp_popnames)] popname_matches ## [1] &quot;Black Butte&quot; &quot;Lostine&quot; &quot;Redbird&quot; &quot;Wenaha&quot; ## [5] &quot;Asotin&quot; &quot;Big Canyon&quot; &quot;Mountain View&quot; &quot;Tucannon&quot; Which population names don’t match between the two sources? # population names in shapefile but not location data: popname_inshpnotloc &lt;- shp_popnames[-which(shp_popnames %in% loc_popnames)] popname_inshpnotloc ## [1] &quot;Lower Hells Canyon&quot; &quot;Muir Creek&quot; &quot;Bear Creek&quot; ## [4] &quot;Saddle Cr.&quot; &quot;Lower Imnaha&quot; &quot;Upper Hells Canyon ID&quot; ## [7] &quot;Upper Hells Canyon OR&quot; # population names in location data but not shapefile: popname_inlocnotshp &lt;- loc_popnames[-which(loc_popnames %in% shp_popnames)] popname_inlocnotshp ## [1] &quot;Imnaha&quot; &quot;Minam&quot; &quot;Sheep Divide&quot; &quot;Quartz&quot; ## [5] &quot;Myers&quot; &quot;05IMREL&quot; &quot;Sheep Mountain&quot; &quot;Muir&quot; ## [9] &quot;UHC-ID&quot; &quot;UHC-OR&quot; &quot;LowerHellsCanyon&quot; &quot;Upper Saddle&quot; ## [13] &quot;McGraw&quot; Update the mis-matched population names to the naming conventions in the location data: # update shapefile population names to match location data population names: popn_ranges[which(popn_ranges$Population==&quot;Lower Hells Canyon&quot;),]$Population &lt;- &quot;LowerHellsCanyon&quot; popn_ranges[which(popn_ranges$Population==&quot;Muir Creek&quot;),]$Population &lt;- &quot;Muir&quot; popn_ranges[which(popn_ranges$Population==&quot;Saddle Cr.&quot;),]$Population &lt;- &quot;Upper Saddle&quot; popn_ranges[which(popn_ranges$Population==&quot;Lower Imnaha&quot;),]$Population &lt;- &quot;Imnaha&quot; popn_ranges[which(popn_ranges$Population==&quot;Upper Hells Canyon ID&quot;),]$Population &lt;- &quot;UHC-ID&quot; popn_ranges[which(popn_ranges$Population==&quot;Upper Hells Canyon OR&quot;),]$Population &lt;- &quot;UHC-OR&quot; Now that we have updated the population names that we could, re-check which population names match betweeen the two sources and which still don’t match: # re-check population matching: loc_popnames &lt;- unique(nonsf_dat$POPULATION) shp_popnames &lt;- unique(popn_ranges$Population) # populations that match: popname_matches &lt;- loc_popnames[which(loc_popnames %in% shp_popnames)] popname_matches ## [1] &quot;Black Butte&quot; &quot;Imnaha&quot; &quot;Lostine&quot; &quot;Redbird&quot; ## [5] &quot;Wenaha&quot; &quot;Asotin&quot; &quot;Big Canyon&quot; &quot;Mountain View&quot; ## [9] &quot;Tucannon&quot; &quot;Muir&quot; &quot;UHC-ID&quot; &quot;UHC-OR&quot; ## [13] &quot;LowerHellsCanyon&quot; &quot;Upper Saddle&quot; # populations that still don&#39;t match: popname_inshpnotloc &lt;- shp_popnames[-which(shp_popnames %in% loc_popnames)] popname_inshpnotloc ## [1] &quot;Bear Creek&quot; popname_inlocnotshp &lt;- loc_popnames[-which(loc_popnames %in% shp_popnames)] popname_inlocnotshp ## [1] &quot;Minam&quot; &quot;Sheep Divide&quot; &quot;Quartz&quot; &quot;Myers&quot; ## [5] &quot;05IMREL&quot; &quot;Sheep Mountain&quot; &quot;McGraw&quot; Bear Creek is a population in the shapefile that does not have a match in the location data. Minam, Sheep Divide, Quartz, Myers, 05IMREL, Sheep Mountain, and McGraw are population names in the location data that do not have a population match in the shapefile. Before finalizing the multi-state model we will check whether we can get data or clarification on the status of these populations, but for now we will simply remove the location data of individuals assigned to these populations: # Remove individuals from populations not in shapefile from the location dataset ---- nonsf_dat &lt;- nonsf_dat[which(nonsf_dat$POPULATION %in% popn_ranges$Population),] We will also remove any individuals that were translocated from the dataset before we assign our states and state-switches because we expect their movement patterns to be different than those of resident sheep, and for now we just want to look at the more “typical” movements of resident sheep in our analysis. # Remove translocated individuals from the datasets ---- nonsf_dat &lt;- nonsf_dat[which(nonsf_dat$SOURCE == &quot;R&quot;),] 3.1.2.2 Set location data and shapefile to same coordinate reference system (CRS) Here we format the location data and shapefile so that they align correctly spatially. I first create the new object dat so that we have both an sf data object (dat) as well as a non-sf data object (nonsf_dat); I do this so that we have the location data in the spatial format used by R for spatial calculations and plotting, and retain the the nonsf_dat object so that the path connecting the locations can later be added to plots using ggplot2::geom_path. # turn location data frame into a sf object: dat &lt;- st_as_sf(nonsf_dat, coords = c(&quot;x_&quot;, &quot;y_&quot;), crs = 32611) Now I set the CRS of the population ranges shapefile and location data points to match: # check CRS of each data source st_crs(popn_ranges) ## Coordinate Reference System: ## User input: NAD83 / UTM zone 11N ## wkt: ## PROJCRS[&quot;NAD83 / UTM zone 11N&quot;, ## BASEGEOGCRS[&quot;NAD83&quot;, ## DATUM[&quot;North American Datum 1983&quot;, ## ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4269]], ## CONVERSION[&quot;UTM zone 11N&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,0, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-117, ## ANGLEUNIT[&quot;Degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,500000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## ID[&quot;EPSG&quot;,26911]] st_crs(dat) ## Coordinate Reference System: ## User input: EPSG:32611 ## wkt: ## PROJCRS[&quot;WGS 84 / UTM zone 11N&quot;, ## BASEGEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;], ## MEMBER[&quot;World Geodetic System 1984 (G2139)&quot;], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]], ## ENSEMBLEACCURACY[2.0]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4326]], ## CONVERSION[&quot;UTM zone 11N&quot;, ## METHOD[&quot;Transverse Mercator&quot;, ## ID[&quot;EPSG&quot;,9807]], ## PARAMETER[&quot;Latitude of natural origin&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8801]], ## PARAMETER[&quot;Longitude of natural origin&quot;,-117, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8802]], ## PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8805]], ## PARAMETER[&quot;False easting&quot;,500000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8806]], ## PARAMETER[&quot;False northing&quot;,0, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8807]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;Navigation and medium accuracy spatial referencing.&quot;], ## AREA[&quot;Between 120°W and 114°W, northern hemisphere between equator and 84°N, onshore and offshore. Canada - Alberta; British Columbia (BC); Northwest Territories (NWT); Nunavut. Mexico. United States (USA).&quot;], ## BBOX[0,-120,84,-114]], ## ID[&quot;EPSG&quot;,32611]] # update shapefile CRS to match location data points CRS popn_ranges &lt;- st_transform(popn_ranges, crs = 32611) # check that the above worked appropriately st_crs(dat)==st_crs(popn_ranges) ## [1] TRUE 3.2 State assignment Assign each bighorn sheep location to a state indicating if the individual was located within its own home population range (state = home), within an other population range that is not its home population range (state = other), or was not located in any known bighorn sheep population range (state = transit). # for each location, report which population range polygon (if any) it&#39;s in polygon_in &lt;- st_intersects(dat, popn_ranges) # add the polygon a location is in as a column to the data # (note: this will classify locations not in a population range polygon as NA) dat$polygon_in &lt;- as.numeric(as.character(polygon_in)) # report the name of the population the point was located in, # or NA if it was not within any population range dat$population_in &lt;- popn_ranges[dat$polygon_in, ]$Population # create a state column # denoting if an individual was located in their home population, # in an other population, or in transit (i.e. not in any population): dat$state &lt;- NA dat[which(dat$population_in==dat$POPULATION),]$state &lt;- &quot;home_population&quot; dat[which(dat$population_in!=dat$POPULATION),]$state &lt;- &quot;other_population&quot; dat[which(is.na(dat$population_in)),]$state &lt;- &quot;transit&quot; Plot location data colored by state on top of the population ranges: ggplot() + geom_sf(data = popn_ranges[,5], size = 3, color = &quot;black&quot;, aes(fill = Population)) + geom_sf(data = dat, size = 1, aes(color = state), alpha=0.25) + ggtitle(&quot;Hells Canyon bighorn sheep locations and population ranges&quot;) + coord_sf(xlim=c(415656.271001306, 573522.865745345), ylim=c(4947089.96507637, 5175432.83718414)) + # set extent to match transit points scale_color_viridis_d()+ #theme_light() theme_void() Save the figure created above: ggsave(filename = &quot;figures/population_shapefile_with_bighorn_locations_colored_by_state_alldata_2024-08.tiff&quot;, device = &quot;tiff&quot;, width = 14, height = 8, units = &quot;in&quot;, dpi = 400) Examine the distribution of states in the data: # number of points assigned to each state across location dataset: table(dat$state) ## ## home_population other_population transit ## 742317 32539 278855 #proportion of locations in each state: round(table(dat$state)/nrow(dat), 2) ## ## home_population other_population transit ## 0.70 0.03 0.26 Examine the distribution of states in the data by demographic group: # for each demographic group (unique sex + age class combo), # tally the number of points in the dataset classified in each state: dat %&gt;% as_tibble() %&gt;% mutate(sex_age_combo = case_when( SEX == &quot;F&quot; &amp; AGECLASS == &quot;Adult&quot; ~ &quot;Adult Female&quot;, SEX == &quot;M&quot; &amp; AGECLASS == &quot;Adult&quot; ~ &quot;Adult Male&quot;, SEX == &quot;F&quot; &amp; AGECLASS == &quot;Yearling&quot; ~ &quot;Yearling Female&quot;, SEX == &quot;M&quot; &amp; AGECLASS == &quot;Yearling&quot; ~ &quot;Yearling Male&quot;, SEX == &quot;F&quot; &amp; AGECLASS == &quot;Lamb&quot; ~ &quot;Lamb Female&quot;, SEX == &quot;M&quot; &amp; AGECLASS == &quot;Lamb&quot; ~ &quot;Lamb Male&quot;, is.na(AGECLASS) &amp; SEX == &quot;F&quot; ~ &quot;Unknown Female&quot;, is.na(AGECLASS) &amp; SEX == &quot;M&quot; ~ &quot;Unknown Male&quot;, )) %&gt;% group_by(sex_age_combo, state) %&gt;% tally() %&gt;% arrange(desc(n)) ## # A tibble: 21 × 3 ## # Groups: sex_age_combo [7] ## sex_age_combo state n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Adult Female home_population 469785 ## 2 Adult Female transit 233509 ## 3 Adult Male home_population 186710 ## 4 Adult Male transit 26708 ## 5 Yearling Female home_population 24801 ## 6 Lamb Female home_population 24595 ## 7 Lamb Male home_population 18854 ## 8 Adult Male other_population 17925 ## 9 Yearling Male home_population 17278 ## 10 Adult Female other_population 7964 ## # ℹ 11 more rows 3.3 State-switches For each individual bighorn sheep in the movement dataset track the state transitions they make (if any). Do this by checking if the end location of each movement step is in a different state than the start location of the step. # Add the state switch information to the dataset dat &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$ANIMALID), function(x){ ind_dat &lt;- dat[which(dat$ANIMALID==x),] if (nrow(ind_dat) &gt; 1){ state_switches &lt;- do.call(&quot;c&quot;, lapply(2:nrow(ind_dat), function(y){ current_state &lt;- ind_dat$state[y] previous_state &lt;- ind_dat$state[y-1] if (current_state == previous_state) {state_switch &lt;- &quot;no&quot;} else { # specify the type of state switch state_switch &lt;- paste0(previous_state, &quot;_to_&quot;, current_state)} return(state_switch) })) ind_dat$state_switches &lt;- c(NA, state_switches) # NA for 1st point } else { ind_dat$state_switches &lt;- NA } return(ind_dat) })) Examine the total number of each state-switch hype in the data, as well as the proportion of each state-switch type in the data # total number of state switches in data set: table(dat$state_switches) ## ## home_population_to_other_population home_population_to_transit ## 2523 12522 ## no other_population_to_home_population ## 1021550 2487 ## other_population_to_transit transit_to_home_population ## 552 12472 ## transit_to_other_population ## 552 # percentage of state switches in data set: round((table(dat[which(!is.na(dat$state_switches)),]$state_switches)/nrow(dat[which(!is.na(dat$state_switches)),]))*100, 2) ## ## home_population_to_other_population home_population_to_transit ## 0.24 1.19 ## no other_population_to_home_population ## 97.04 0.24 ## other_population_to_transit transit_to_home_population ## 0.05 1.18 ## transit_to_other_population ## 0.05 For each demographic group (unique sex + age class combo), tally the number of points in the dataset classified as each state-switch type: dat %&gt;% as_tibble() %&gt;% # remove NA state_switches corresponding to first location of each individual filter(!is.na(state_switches)) %&gt;% mutate(sex_age_combo = case_when( SEX == &quot;F&quot; &amp; AGECLASS == &quot;Adult&quot; ~ &quot;Adult Female&quot;, SEX == &quot;M&quot; &amp; AGECLASS == &quot;Adult&quot; ~ &quot;Adult Male&quot;, SEX == &quot;F&quot; &amp; AGECLASS == &quot;Yearling&quot; ~ &quot;Yearling Female&quot;, SEX == &quot;M&quot; &amp; AGECLASS == &quot;Yearling&quot; ~ &quot;Yearling Male&quot;, SEX == &quot;F&quot; &amp; AGECLASS == &quot;Lamb&quot; ~ &quot;Lamb Female&quot;, SEX == &quot;M&quot; &amp; AGECLASS == &quot;Lamb&quot; ~ &quot;Lamb Male&quot;, is.na(AGECLASS) &amp; SEX == &quot;F&quot; ~ &quot;Unknown Female&quot;, is.na(AGECLASS) &amp; SEX == &quot;M&quot; ~ &quot;Unknown Male&quot;, )) %&gt;% group_by(sex_age_combo, state_switches) %&gt;% tally() %&gt;% arrange(desc(n)) ## # A tibble: 45 × 3 ## # Groups: sex_age_combo [7] ## sex_age_combo state_switches n ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Adult Female no 690180 ## 2 Adult Male no 223201 ## 3 Yearling Female no 29985 ## 4 Lamb Female no 28952 ## 5 Lamb Male no 26753 ## 6 Yearling Male no 22188 ## 7 Adult Female home_population_to_transit 8465 ## 8 Adult Female transit_to_home_population 8425 ## 9 Adult Male home_population_to_transit 3050 ## 10 Adult Male transit_to_home_population 3037 ## # ℹ 35 more rows 3.4 Create additional summary data For each individual, tally the number of populations they were in and the number of state switches in their data: # split data by individual dats &lt;- split(dat, dat$ANIMALID) # tally the number of populations each individual was in and number of state switches popns_in &lt;- do.call(&quot;rbind&quot;, lapply(1:length(dats), function(x){ ind_dat &lt;- dats[[x]] tot_popns &lt;- length(unique(ind_dat$population_in[which(!is.na(ind_dat$population_in))])) if(any(is.na(ind_dat$population_in))) {in_transit &lt;- T} else {in_transit &lt;- F} tot_popns_and_transit &lt;- length(unique(ind_dat$population_in)) all_popns_in &lt;- paste(unique(ind_dat$population_in[which(!is.na(ind_dat$population_in))]), collapse=&quot;; &quot;) start_date &lt;- min(ind_dat$datetime) end_date &lt;- max(ind_dat$datetime) time_tracked &lt;- difftime(end_date, start_date) # tally state switches total_state_switches &lt;- length(intersect(which(!is.na(ind_dat$state_switches)), which(ind_dat$state_switches!=&quot;no&quot;))) total_home_to_transit &lt;- length(which(ind_dat$state_switches == &quot;home_population_to_transit&quot;)) total_home_to_other &lt;- length(which(ind_dat$state_switches == &quot;home_population_to_other_population&quot;)) total_transit_to_home &lt;- length(which(ind_dat$state_switches == &quot;transit_to_home_population&quot;)) total_transit_to_other &lt;- length(which(ind_dat$state_switches == &quot;transit_to_other_population&quot;)) total_other_to_home &lt;- length(which(ind_dat$state_switches == &quot;other_population_to_home_population&quot;)) total_other_to_transit &lt;- length(which(ind_dat$state_switches == &quot;other_population_to_transit&quot;)) return(data.frame(animalID=unique(ind_dat$ANIMALID), source=paste0(unique(ind_dat$SOURCE), collapse=&quot;; &quot;), home_popn= unique(ind_dat$POPULATION), tot_popns=tot_popns, in_transit = in_transit, tot_popns_and_transit=tot_popns_and_transit, all_popns_in=all_popns_in, total_state_switches=total_state_switches, total_home_to_transit=total_home_to_transit, total_home_to_other=total_home_to_other, total_transit_to_home=total_transit_to_home, total_transit_to_other=total_transit_to_other, total_other_to_home=total_other_to_home, total_other_to_transit=total_other_to_transit, start_date=start_date, end_date=end_date, time_tracked=time_tracked, switches_per_year=round(total_state_switches/(as.numeric(time_tracked)/365.25), 1))) })) # examine the first few rows of the summary data frame head(popns_in) ## animalID source home_popn tot_popns in_transit tot_popns_and_transit ## 1 00B14 R Black Butte 1 TRUE 2 ## 2 00B15 R Black Butte 1 FALSE 1 ## 3 00B16 R Black Butte 1 TRUE 2 ## 4 00B17 R Black Butte 1 TRUE 2 ## 5 00B19 R Black Butte 3 TRUE 4 ## 6 00I37 R Imnaha 2 FALSE 2 ## all_popns_in total_state_switches ## 1 Black Butte 6 ## 2 Black Butte 0 ## 3 Black Butte 6 ## 4 Black Butte 4 ## 5 Black Butte; Mountain View; Redbird 6 ## 6 Imnaha; LowerHellsCanyon 2 ## total_home_to_transit total_home_to_other total_transit_to_home ## 1 3 0 3 ## 2 0 0 0 ## 3 3 0 3 ## 4 2 0 2 ## 5 1 2 1 ## 6 0 1 0 ## total_transit_to_other total_other_to_home total_other_to_transit ## 1 0 0 0 ## 2 0 0 0 ## 3 0 0 0 ## 4 0 0 0 ## 5 0 2 0 ## 6 0 1 0 ## start_date end_date time_tracked switches_per_year ## 1 2000-02-15 09:50:00 2002-11-07 13:00:00 996.1319 days 2.2 ## 2 2000-02-15 10:40:00 2003-05-23 10:25:00 1192.9479 days 0.0 ## 3 2000-02-15 09:50:00 2002-04-17 09:40:00 791.9514 days 2.8 ## 4 2000-02-15 12:45:00 2003-05-23 10:20:00 1192.8576 days 1.2 ## 5 2000-02-15 10:40:00 2003-02-19 10:38:00 1099.9986 days 2.0 ## 6 2000-02-02 10:40:00 2000-12-04 16:15:00 306.2326 days 2.4 Calculate the proportion of states by different grouping variables: # make age and sex ordered factor levels dat$SEX &lt;- factor(dat$SEX, levels=c(&quot;F&quot;, &quot;M&quot;)) dat$AGECLASS &lt;- factor(dat$AGECLASS, levels=c(&quot;Adult&quot;, &quot;Yearling&quot;, &quot;Lamb&quot;)) # create an age_sex column on dat that combines age class and sex dat$agesex &lt;- factor(paste0(substr(dat$AGECLASS, 1, 1), dat$SEX), levels=c(&quot;AF&quot;, &quot;AM&quot;, &quot;YF&quot;, &quot;YM&quot;, &quot;LF&quot;, &quot;LM&quot;)) # proportion of states by age: stateswitch_byage &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$AGECLASS), function(x){ agedat &lt;- dat[which(dat$AGECLASS==x),] percent_home &lt;- round((nrow(agedat[which(agedat$state==&quot;home_population&quot;),])/nrow(agedat))*100, 2) percent_other &lt;-round((nrow(agedat[which(agedat$state==&quot;other_population&quot;),])/nrow(agedat))*100, 2) percent_transit &lt;- round((nrow(agedat[which(agedat$state==&quot;transit&quot;),])/nrow(agedat))*100, 2) return(data.frame(age_class=x, percent_home=percent_home, percent_transit=percent_transit, percent_other=percent_other)) })) # proportion of states by sex: stateswitch_bysex &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$SEX), function(x){ sexdat &lt;- dat[which(dat$SEX==x),] percent_home &lt;- round((nrow(sexdat[which(sexdat$state==&quot;home_population&quot;),])/nrow(sexdat))*100, 2) percent_other &lt;-round((nrow(sexdat[which(sexdat$state==&quot;other_population&quot;),])/nrow(sexdat))*100, 2) percent_transit &lt;- round((nrow(sexdat[which(sexdat$state==&quot;transit&quot;),])/nrow(sexdat))*100, 2) return(data.frame(sex=x, percent_home=percent_home, percent_transit=percent_transit, percent_other=percent_other)) })) # proportion of states by sex + age combo: stateswitch_byagesex &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$agesex), function(x){ agesexdat &lt;- dat[which(dat$agesex==x),] percent_home &lt;- round((nrow(agesexdat[which(agesexdat$state==&quot;home_population&quot;),])/nrow(agesexdat))*100, 2) percent_other &lt;-round((nrow(agesexdat[which(agesexdat$state==&quot;other_population&quot;),])/nrow(agesexdat))*100, 2) percent_transit &lt;- round((nrow(agesexdat[which(agesexdat$state==&quot;transit&quot;),])/nrow(agesexdat))*100, 2) return(data.frame(agesex=x, percent_home=percent_home, percent_transit=percent_transit, percent_other=percent_other)) })) # proportion of states by home population: stateswitch_byhome &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$POPULATION), function(x){ popndat &lt;- dat[which(dat$POPULATION==x),] percent_home &lt;- round((nrow(popndat[which(popndat$state==&quot;home_population&quot;),])/nrow(popndat))*100, 2) percent_other &lt;-round((nrow(popndat[which(popndat$state==&quot;other_population&quot;),])/nrow(popndat))*100, 2) percent_transit &lt;- round((nrow(popndat[which(popndat$state==&quot;transit&quot;),])/nrow(popndat))*100, 2) return(data.frame(home_population=x, percent_home=percent_home, percent_transit=percent_transit, percent_other=percent_other)) })) Calculate the proportion of state switches by different grouping variables: # Calculate the proportion of state switches by different grouping variables ---- # proportion of state_switches switches by age: stateswitch_byage2 &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$AGECLASS), function(x){ agedat &lt;- dat[which(dat$AGECLASS==x),] none &lt;- round((nrow(agedat[which(agedat$state_switches==&quot;no&quot;),])/nrow(agedat))*100, 2) home_population_to_transit &lt;-round((nrow(agedat[which(agedat$state_switches==&quot;home_population_to_transit&quot;),])/nrow(agedat))*100, 2) transit_to_home_population &lt;- round((nrow(agedat[which(agedat$state_switches==&quot;transit_to_home_population&quot;),])/nrow(agedat))*100, 2) other_population_to_transit &lt;- round((nrow(agedat[which(agedat$state_switches== &quot;other_population_to_transit&quot;),])/nrow(agedat))*100, 2) transit_to_other_population &lt;- round((nrow(agedat[which(agedat$state_switches==&quot;transit_to_other_population&quot;),])/nrow(agedat))*100, 2) home_population_to_other_population &lt;- round((nrow(agedat[which(agedat$state_switches==&quot;home_population_to_other_population&quot;),])/nrow(agedat))*100, 2) other_population_to_home_population &lt;- round((nrow(agedat[which(agedat$state_switches==&quot;other_population_to_home_population&quot;),])/nrow(agedat))*100, 2) return(data.frame(age_class=x, none=none, home_population_to_transit=home_population_to_transit, transit_to_home_population=transit_to_home_population, other_population_to_transit=other_population_to_transit, transit_to_other_population=transit_to_other_population, home_population_to_other_population=home_population_to_other_population, other_population_to_home_population=other_population_to_home_population )) })) # proportion of state_switches switches by sex: stateswitch_bysex2 &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$SEX), function(x){ sexdat &lt;- dat[which(dat$SEX==x),] none &lt;- round((nrow(sexdat[which(sexdat$state_switches==&quot;no&quot;),])/nrow(sexdat))*100, 2) home_population_to_transit &lt;-round((nrow(sexdat[which(sexdat$state_switches==&quot;home_population_to_transit&quot;),])/nrow(sexdat))*100, 2) transit_to_home_population &lt;- round((nrow(sexdat[which(sexdat$state_switches==&quot;transit_to_home_population&quot;),])/nrow(sexdat))*100, 2) other_population_to_transit &lt;- round((nrow(sexdat[which(sexdat$state_switches== &quot;other_population_to_transit&quot;),])/nrow(sexdat))*100, 2) transit_to_other_population &lt;- round((nrow(sexdat[which(sexdat$state_switches==&quot;transit_to_other_population&quot;),])/nrow(sexdat))*100, 2) home_population_to_other_population &lt;- round((nrow(sexdat[which(sexdat$state_switches==&quot;home_population_to_other_population&quot;),])/nrow(sexdat))*100, 2) other_population_to_home_population &lt;- round((nrow(sexdat[which(sexdat$state_switches==&quot;other_population_to_home_population&quot;),])/nrow(sexdat))*100, 2) return(data.frame(sex=x, none=none, home_population_to_transit=home_population_to_transit, transit_to_home_population=transit_to_home_population, other_population_to_transit=other_population_to_transit, transit_to_other_population=transit_to_other_population, home_population_to_other_population=home_population_to_other_population, other_population_to_home_population=other_population_to_home_population)) })) # proportion of state_switches switches by sex + age combo: stateswitch_byagesex2 &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$agesex), function(x){ agesexdat &lt;- dat[which(dat$agesex==x),] none &lt;- round((nrow(agesexdat[which(agesexdat$state_switches==&quot;no&quot;),])/nrow(agesexdat))*100, 2) home_population_to_transit &lt;-round((nrow(agesexdat[which(agesexdat$state_switches==&quot;home_population_to_transit&quot;),])/nrow(agesexdat))*100, 2) transit_to_home_population &lt;- round((nrow(agesexdat[which(agesexdat$state_switches==&quot;transit_to_home_population&quot;),])/nrow(agesexdat))*100, 2) other_population_to_transit &lt;- round((nrow(agesexdat[which(agesexdat$state_switches== &quot;other_population_to_transit&quot;),])/nrow(agesexdat))*100, 2) transit_to_other_population &lt;- round((nrow(agesexdat[which(agesexdat$state_switches==&quot;transit_to_other_population&quot;),])/nrow(agesexdat))*100, 2) home_population_to_other_population &lt;- round((nrow(agesexdat[which(agesexdat$state_switches==&quot;home_population_to_other_population&quot;),])/nrow(agesexdat))*100, 2) other_population_to_home_population &lt;- round((nrow(agesexdat[which(agesexdat$state_switches==&quot;other_population_to_home_population&quot;),])/nrow(agesexdat))*100, 2) return(data.frame(agesex=x, none=none, home_population_to_transit=home_population_to_transit, transit_to_home_population=transit_to_home_population, other_population_to_transit=other_population_to_transit, transit_to_other_population=transit_to_other_population, home_population_to_other_population=home_population_to_other_population, other_population_to_home_population=other_population_to_home_population)) })) # proportion of state_switches switches by home population: stateswitch_byhome2 &lt;- do.call(&quot;rbind&quot;, lapply(unique(dat$POPULATION), function(x){ popndat &lt;- dat[which(dat$POPULATION==x),] none &lt;- round((nrow(popndat[which(popndat$state_switches==&quot;no&quot;),])/nrow(popndat))*100, 2) home_population_to_transit &lt;-round((nrow(popndat[which(popndat$state_switches==&quot;home_population_to_transit&quot;),])/nrow(popndat))*100, 2) transit_to_home_population &lt;- round((nrow(popndat[which(popndat$state_switches==&quot;transit_to_home_population&quot;),])/nrow(popndat))*100, 2) other_population_to_transit &lt;- round((nrow(popndat[which(popndat$state_switches== &quot;other_population_to_transit&quot;),])/nrow(popndat))*100, 2) transit_to_other_population &lt;- round((nrow(popndat[which(popndat$state_switches==&quot;transit_to_other_population&quot;),])/nrow(popndat))*100, 2) home_population_to_other_population &lt;- round((nrow(popndat[which(popndat$state_switches==&quot;home_population_to_other_population&quot;),])/nrow(popndat))*100, 2) other_population_to_home_population &lt;- round((nrow(popndat[which(popndat$state_switches==&quot;other_population_to_home_population&quot;),])/nrow(popndat))*100, 2) return(data.frame(home_population=x, none=none, home_population_to_transit=home_population_to_transit, transit_to_home_population=transit_to_home_population, other_population_to_transit=other_population_to_transit, transit_to_other_population=transit_to_other_population, home_population_to_other_population=home_population_to_other_population, other_population_to_home_population=other_population_to_home_population)) })) 3.5 Data visualization 3.5.1 histograms of state-switches # histogram of state switches in current data set: ggplot(popns_in, aes(x=total_state_switches))+ geom_histogram(color=&quot;black&quot;, fill=&quot;grey50&quot;, bins=100)+ theme_light()+ xlab(&quot;number of state switches&quot;)+ ylab(&quot;number of individuals&quot;)+ ggtitle(&quot;distribution of number of state switches in resident data&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 13)) 3.5.2 Examine the number of populations individuals were found in across their data: # Examine the number of populations individuals were found in # across the time their movements were tracked totpopns &lt;- data.frame(table(popns_in$tot_popns)) colnames(totpopns) &lt;- c(&quot;total_populations_in&quot;, &quot;number_individuals&quot;) # plot the number of populations individuals were found in ggplot(totpopns, aes(x=total_populations_in, y=number_individuals)) + geom_bar(stat=&quot;identity&quot;)+ theme_bw()+ xlab(&quot;total populations in&quot;)+ ylab(&quot;number of individuals&quot;)+ ggtitle(&quot;number of populations located in per individual&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 15)) 3.5.3 Examine number of locations in each state across the data: # barplot of number of locations in each state ggplot(dat, aes(x=state, fill = state))+ geom_bar()+ theme_light()+ xlab(&quot;state&quot;)+ ylab(&quot;number of points in state&quot;)+ ggtitle(&quot;number of locations in each state&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 18), legend.position = &quot;none&quot;) 3.5.4 Examine number of state switches across the data: # barplot of number of each state transition type ggplot(dat[intersect(which(!is.na(dat$state_switches)), which(dat$state_switches!=&quot;no&quot;)),], aes(x=state_switches, fill = state_switches))+ geom_bar()+ theme_light()+ xlab(&quot;state switch&quot;)+ ylab(&quot;number of state switches&quot;)+ ggtitle(&quot;number each state switch type&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 14), axis.text.x = element_blank()) 3.5.5 Examine state switches by age: # examine state switching vs age ---- # number of state switches by age: ggplot(dat[intersect(intersect(which(!is.na(dat$state_switches)), which(dat$state_switches!=&quot;no&quot;)), which(!is.na(dat$AGECLASS))),], aes(x=AGECLASS, fill = AGECLASS))+ geom_bar()+ theme_light()+ xlab(&quot;age class&quot;)+ ylab(&quot;number of state switches&quot;)+ ggtitle(&quot;total number of state switches by age&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 18), legend.position=&quot;none&quot;) 3.5.6 Plot state proportions by age: # plot state proportions by age: stateswitch_byage %&gt;% filter(!is.na(stateswitch_byage$age_class)) %&gt;% pivot_longer(cols=c(&quot;percent_home&quot;, &quot;percent_transit&quot;, &quot;percent_other&quot;), names_to = &quot;state&quot;) %&gt;% ggplot(aes(x = age_class, y = value, fill = state))+ geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;) + theme_light()+ xlab(&quot;age class&quot;)+ ylab(&quot;percent of locations&quot;)+ ggtitle(&quot;state proportions by age&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 15)) + scale_fill_viridis_d(labels=c(&quot;home population&quot;, &quot;other population&quot;, &quot;transit&quot;)) 3.5.7 Plot state proportions by sex: # state proportions by sex: stateswitch_bysex %&gt;% pivot_longer(cols=c(&quot;percent_home&quot;, &quot;percent_transit&quot;, &quot;percent_other&quot;), names_to = &quot;state&quot;) %&gt;% ggplot(aes(x = sex, y = value, fill = state))+ geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;) + theme_light()+ xlab(&quot;sex&quot;)+ ylab(&quot;percent of locations&quot;)+ ggtitle(&quot;state proportions by sex&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 15)) + scale_fill_viridis_d(labels=c(&quot;home population&quot;, &quot;other population&quot;, &quot;transit&quot;)) 3.5.8 Plot state proportions by age + sex combo: # plot state proportions by age + sex combo: stateswitch_byagesex %&gt;% filter(!is.na(stateswitch_byagesex$agesex)) %&gt;% pivot_longer(cols=c(&quot;percent_home&quot;, &quot;percent_transit&quot;, &quot;percent_other&quot;), names_to = &quot;state&quot;) %&gt;% ggplot(aes(x = agesex, y = value, fill = state))+ geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;) + theme_light()+ xlab(&quot;age + sex&quot;)+ ylab(&quot;percent of locations&quot;)+ ggtitle(&quot;state proportions by age + sex&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 15)) + scale_fill_viridis_d(labels=c(&quot;home population&quot;, &quot;other population&quot;, &quot;transit&quot;)) 3.5.9 Plot state proportions by population: # plot state proportions by home population: stateswitch_byhome %&gt;% pivot_longer(cols=c(&quot;percent_home&quot;, &quot;percent_transit&quot;, &quot;percent_other&quot;), names_to = &quot;state&quot;) %&gt;% ggplot(aes(x = home_population, y = value, fill = state))+ geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;) + theme_light()+ xlab(&quot;home population&quot;)+ ylab(&quot;percent of locations&quot;)+ ggtitle(&quot;state proportions by home population&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 14), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+ scale_fill_viridis_d(labels=c(&quot;home population&quot;, &quot;other population&quot;, &quot;transit&quot;)) 3.5.10 Plot state switch proportions by age + sex combo: # plot state switch proportions by age + sex combo # (without none category) stateswitch_byagesex2 %&gt;% filter(!is.na(stateswitch_byagesex2$agesex)) %&gt;% pivot_longer(cols=colnames(stateswitch_byagesex2)[2:ncol(stateswitch_byagesex2)], names_to = &quot;state_switch&quot;) %&gt;% filter(state_switch != &quot;none&quot;) %&gt;% ggplot(aes(x = agesex, y = value, fill = state_switch))+ geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;) + theme_light()+ xlab(&quot;age + sex&quot;)+ ylab(&quot;percent of locations&quot;)+ ggtitle(&quot;state switch proportions by age + sex&quot;)+ theme(plot.title=element_text(hjust=0.5), text=element_text(size = 14)) + scale_fill_discrete(labels=c(&quot;home to other&quot;, &quot;home to transit&quot;, &quot;other to home&quot;, &quot;other to transit&quot;, &quot;transit to home&quot;, &quot;transit to other&quot;), name = &quot;state switch&quot;) 3.5.11 Plot state switch proportions by home population: # plot state switch proportions by home population: # (without the none category) stateswitch_byhome2 %&gt;% pivot_longer(cols=colnames(stateswitch_byhome2)[2:ncol(stateswitch_byhome2)], names_to = &quot;state_switch&quot;) %&gt;% filter(state_switch != &quot;none&quot;) %&gt;% ggplot(aes(x = home_population, y = value, fill = state_switch))+ geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;) + theme_light()+ xlab(&quot;home population&quot;)+ ylab(&quot;percent of locations&quot;)+ ggtitle(&quot;state switch proportions by home population&quot;)+ theme(plot.title=element_text(hjust=0.5), axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), text=element_text(size = 14)) + scale_fill_discrete(labels=c(&quot;home to other&quot;, &quot;home to transit&quot;, &quot;other to home&quot;, &quot;other to transit&quot;, &quot;transit to home&quot;, &quot;transit to other&quot;), name = &quot;state switch&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
